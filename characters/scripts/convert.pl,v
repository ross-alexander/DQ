head	1.7;
access;
symbols;
locks
	ralexand:1.7; strict;
comment	@# @;


1.7
date	2018.03.24.11.04.18;	author ralexand;	state Exp;
branches;
next	1.6;

1.6
date	2015.03.07.12.47.05;	author ralexand;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.24.15.46.34;	author ralexand;	state Exp;
branches;
next	1.4;

1.4
date	2007.08.08.09.51.35;	author ralexand;	state Exp;
branches;
next	1.3;

1.3
date	2006.08.21.14.14.24;	author ralexand;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.11.17.28.01;	author ralexand;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.11.17.23.59;	author ralexand;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Summary: Remove old TeX to XML functions.
@
text
@#!/usr/bin/perl -I/home/ralexand/dq/characters/scripts

# ----------------------------------------------------------------------
#
# DQ ranking (LaTeX) to JSON or XML
#
# 2018-03-22: Ross Alexander
#   Apply fixes for perl-5.26.1
#
# ----------------------------------------------------------------------


use 5.26.1;
use XML::LibXML;
use Getopt::Long;
use Carp::Assert;
use Encode;
use dq;
use Tick;
use JSON;
use Data::Dumper;

# ----------------------------------------------------------------------
#
# Update_Adventure
#
# ----------------------------------------------------------------------

sub Update_Adventure {

    my ($map, $state, $adventure) = @@_;

    my $tick = $state->{'tick'};

    my $start = new Tick($adventure->{start_tick});
    my $end = new Tick($adventure->{end_tick});

    # --------------------
    # Print out adventure name
    # --------------------

    printf("* ----------------------------------------------------------------------\n");
    printf("* %s [%s - %s]\n", $adventure->{name}, $start, $end);
    printf("* ----------------------------------------------------------------------\n\n");
    
    # --------------------
    # Process Money
    # --------------------
    
    for my $m (@@{$adventure->{monies}})
    {
	next if ($m->{ledger});
	my $in = $m->{in};
	my $out = 0;

	# --------------------
	# Check "in" is correct.
	# --------------------

	if ($state->{money} != $in)
	{
	    printf "Money computed value different from stored value (%d <> %d)\n", $state->{money}, $in;
	    exit(1);
	}
	
	for my $l (@@{$m->{lines}})
	{
	    $in += $l->{in} if (exists($l->{in}));
	    $out += $l->{out} if (exists($l->{out}));
	}

	my $total = $in - $out;
	my $amount = $m->{out};

	if ($amount != $total)
	{
	    print STDERR "Error in money dated ", $m->{date}, " ($amount vs $total).\n";
	    exit(1);
	}
	$state->{money} = $amount;
	printf("Money: in $in -- spent -- $out -- out $amount\n\n");
    }

    # --------------------
    # Check Dates
    # --------------------
    
    if (!defined($tick))
    {
	$tick = new Tick($start);
    }

    if ($tick > $start)
    {
	printf STDERR "Serious start date issue (Current %s [%s] -- Start %s [%s])!\n", $tick, $tick->CDate(), $start, $start->CDate();
	exit 1;
    }
    if ($start > $end)
    {
	printf STDERR "Serious date issue!\n";
	exit 1;
    }

    # --------------------
    # Set current time to end of adventure + 1 day
    # --------------------
    
    $tick->{tick} = $end->{tick} + 1;
    
    # --------------------
    # Iterate over all the ranking nodes
    # --------------------

    my $ep_total = 0;
    
    for my $ranking (@@{$adventure->{ranking}})
    {
	$ranking->{start} =  $tick;
	for my $block (@@{$ranking->{blocks}})
	{
	    # --------------------
	    # Set block level ep and time counters to zero
	    # --------------------
	    
	    my $block_ep = 0;
	    my @@time = (0, 0, 0);

	    # --------------------
	    # Iterate over every ranking line in the block
	    # --------------------
	    
	    for my $line (@@{$block->{lines}})
	    {
		
		# Get the type ie skill, spell, ritual, etc

		my $type = $line->{type};

		# Make sure valid entry

		if (!exists $map->{$type})
		{
		    print STDERR "Type $type unknown -- exiting.\n";
		    exit 1;
		}

		my $name = $line->{name};

		if ((!exists($line->{initial}) || !length($line->{initial})) && $map->{type}->{__rankable__}) 
		{
		    print STDERR "$type $name does not have initial value.\n";
		    exit 1;
		}

		# --------------------
		# Create hash entry if it don't already exist
		# --------------------
		
		$map->{$type}->{$name} = {} if (!exists $map->{$type}->{$name});
		$map->{$type}->{$name}->{name} = $name;

		$map->{$type}->{$name}->{college} = $line->{college} if ($line->{college});
		$map->{$type}->{$name}->{ref} =  $line->{ref} if ($line->{ref});

		my $initial = $line->{initial};
		my $final = $line->{final};
		my $rank = $map->{$type}->{$name}->{rank};
		my $partial = $line->{partial};

		if (exists($map->{$type}->{$name}->{rank}) && !$partial && ($rank ne $initial))
		{
		    printf "$type $name initial [%s] not same as current rank [%s]\n", $initial, $rank;
		    exit(1);
		}

# Having got the initial ranking value its now time to get the final.

		if (exists($line->{final}) && !$partial)
		{
		    my $old = $map->{$type}->{$name}->{"rank"};
		    $map->{$type}->{$name}->{"rank"} = $final;
		}
		else
		{
		    $map->{$type}->{$name}->{"rank"} = $initial;
		}

		# --------------------
		# Check values
		# --------------------
		
		my ($em, $cep, $ep, $rep, $sum, $diff, $csum);
		
		if ($line->{initial} && $line->{final})
		{
		    $initial = 0 if ($initial eq "U" && ($final > 0));
		    if ($initial ne "U")
		    {
			$sum = $line->{sum};
			$csum = ($type eq "stat") ?
			    $final - $initial :
			    (($final * ($final + 1)) - ($initial * ($initial +1))) / 2;
		    
			if ($csum != $sum)
			{
			    print "Initial = $initial  Final = $final  sum = $csum (sum = $sum).\n";
			    print to_json($line), "\n";
			    exit(1);
			}
			if ($line->{em})
			{
			    $em = $line->{em};
			    $cep = $sum * $em;
			    $ep = $line->{raw_ep} // $line->{ep};
			    if ($cep != $ep)
			    {
				print "EP = $ep -- computed EP $sum * $em = $cep\n";
				print to_json($line), "\n";
				exit(1);
			    }
			}
			if ($line->{ep} && $line->{raw_ep})
			{
			    $ep = $line->{ep};
			    $rep = $line->{raw_ep};
			    $diff = ($rep >= $ep) ? $ep / $rep : $ep / $rep;
			}
		    }
		}

		# --------------------
		# Process time and EP
		# --------------------

		my $time_str = $line->{time};
		$time_str =~ /([0-9]+) (day|days|week|weeks)/;
		my $time = $1;
		$time *= 7 if (($2 eq "week") || ($2 eq "weeks"));
		my $track = $line->{track};
		$line->{day_equiv} = $time;
		$time[$track] += $time;
		$block_ep += $line->{ep};

		printf("%-30s (%3s..%3s) Raw EP = %d EP = %d Diff = %4.2f : Time = %s\n",
		       $name, $initial, $final,
		       $rep, $ep, $diff, $time);
	    }
	    $block->{ep} = $block_ep;
	    $ep_total += $block_ep;

	    # --------------------
	    # sort the time tracks to get maximum
	    # --------------------

	    print "Track times = ", join(" : ", @@time), "\n\n";
	    my @@tsort = sort { $a <=> $b } @@time;
	    $block->{start} = $tick;
	    $block->{time} =  $tsort[$#tsort];

	    if (!($ranking->{star} > 0))
	    {
		$tick += $tsort[$#tsort];
	    }
	}
	$ranking->{end} =  $tick;
    }

    # --------------------
    # Process total Experience
    # --------------------

    my $exp = $adventure->{experience};
    if (defined $exp)
    {
	my $ep_in = $exp->{in};
	my $ep_gained = $exp->{gained};
	my $ep_spent = $exp->{spent};
	my $ep_out = $exp->{out};

	$state->{ep_total} += $ep_gained;
	my $in = $state->{"ep"};

	if ($in != $ep_in)
	{
	    print STDERR "Recorded transferred EP ($ep_in) is different from computed value ($in).\n";
	    exit(1);
	}

	my $out = $in + $ep_gained - $ep_total;

	if ($ep_total != $ep_spent)
	{
	    printf STDERR "Recorded spent EP (%d) is different from computed value (%d) [remaining %d vs %d].\n", $ep_spent, $ep_total, $ep_out, $out;
	    exit(1);
	}
	if ($out != $ep_out)
	{
	    print STDERR "Recorded remaining EP ($ep_out) is different from computed value ($out).\n";
	    exit(1);
	}
	$state->{ep} = $out;

	printf("EP: in %d gained %d spent %d out %d\n", $ep_in, $ep_gained, $ep_spent, $ep_out);
    }

    $state->{"tick"} = $tick;
    printf("Time: start %s - end %s - current %s (%s) [%d]\n", $start->CDate(), $end->CDate(), $tick->CDate(), $tick, $tick - $end);
    printf("\n");
}


# ----------------------------------------------------------------------
#
# XML_File
#
# ----------------------------------------------------------------------

sub Update_Character {

    my ($conf, $character) = @@_;

    # --------------------
    # Create reference to a hash which hold ranking values.
    # --------------------
    
    my $map = {
	'college' => {
	    '__rankable__' => 0,
	},
	'stat' => {
	    '__rankable__' => 1,
	},
	'weapon' => {
	    '__rankable__' => 1,
	},
	'skill' => {
	    '__rankable__' => 1,
	},
	'language' => {
	    '__rankable__' => 1,
	},
	'talent' => {
	    '__rankable__' => 1,
	},
	'spell' => {
	    '__rankable__' => 1,
	},
	'ritual' => {
	    '__rankable__' => 1,
	},
	'itn' => {
	    '__rankable__' => 1,
	},
	'gtn' => {
	    '__rankable__' => 1,
	},
    };

    # --------------------
    # Create refernece to a hash which holds state and values to pass
    # between adventures.
    # --------------------
    
    my $state = {
	'money' => 0,
	'ep' => 0,
	'ep-total' => 0,
	'tick' => undef,
    };

    $map->{'state'} = $state;

    # --------------------
    # Iterate over every adventure and process sequentially.
    # --------------------

    for my $a (@@{$character->{adventures}})
    {
	&Update_Adventure($map, $state, $a);
    }

    $character->{_map_} = $map;
    $character->{_state_} = $state;
}

# ----------------------------------------------------------------------
#
# DoParty
#
# ----------------------------------------------------------------------

sub DoParty {
    my ($in, $adventure) = @@_;
    my $party = $adventure->appendChild(XML::LibXML::Element->new("party"));

    while (<$in>)
    {
	chomp $_;
	return if (m:^\\end\{party\}:);
	s/[ ]?\\\\$//;
	my ($name, $college, $note) = split(/[ \t]+?\&[ ]?/, $_);
	my $member = $party->appendChild(XML::LibXML::Element->new("member"));
	$member->setAttribute("name", $name);
	$member->setAttribute("college", $college);
	$member->setAttribute("note", $note) if (length($note));
    }
    return;
}

# ----------------------------------------------------------------------
#
# DoItems
#
# ----------------------------------------------------------------------

sub DoItems {
    my ($in, $adventure) = @@_;
    my $items = $adventure->appendChild(XML::LibXML::Element->new("items"));

    if (m/^\\begin\{items\}\{([A-Za-z0-9, ]+)\}/)
    {
	$items->setAttribute("desc", $1);
    }

    while (<$in>)
    {
	chomp $_;
	return if (m:^\\end\{items\}:);
	s/[ ]?\\\\$//;
	my $line = $items->appendChild(XML::LibXML::Element->new("line"));
	$line->setAttribute("desc", $_);
    }
    return;
}

# ----------------------------------------------------------------------
#
# DoMoney
#
# ----------------------------------------------------------------------

sub DoMonies {
    my ($in, $adventure) = @@_;
    my $monies = $adventure->appendChild(XML::LibXML::Element->new("monies"));
    my $date;

    if (m/^\\begin\{monies\}\[([A-Za-z ]+)\]\{(-?[0-9]+)\}\{(-?[0-9]+)\}\{([A-Za-z0-9\/,\. ]+)\}/)
    {
	$monies->setAttribute("desc", $1);
	$monies->setAttribute("in", $2);
	$monies->setAttribute("out", $3);
	$monies->setAttribute("date", $4);
	$date = $4;
    }
    elsif (m/^\\begin\{monies\}\{(-?[0-9]+)\}\{(-?[0-9]+)\}\{([A-Za-z0-9\/,\. ]+)\}/)
    {
	$monies->setAttribute("in", $1);
	$monies->setAttribute("out", $2);
	$monies->setAttribute("date", $3);
	$date = $3;
    }

    my $tick = new Tick($date);
    
    $monies->setAttribute("tick", $tick->{tick});
    $monies->setAttribute("calendar", $tick->{calendar});

    while (<$in>)
    {
	chomp $_;
	return if (m:^\\end\{monies\}:);
	s/[ ]?\\\\([ ]?(\\hline)?)$//;
	my ($desc, $out, $in) = split(/[ \t]+?\&[ ]?/, $_);
	my $line = $monies->appendChild(XML::LibXML::Element->new("line"));
	$line->setAttribute("desc", $desc);
	$line->setAttribute("out", $out) if (length($out));
	$line->setAttribute("in", $in) if (length($in) && !length($out));
    }
}

# ----------------------------------------------------------------------
#
# DoRanking
#
# ----------------------------------------------------------------------

sub DoRanking {
    my ($in, $root) = @@_;
    m/\\begin\{(ranking\*?)\}\{(.*)\}\{(.*)\}/;

    my $ranking = $root->appendChild(XML::LibXML::Element->new("ranking"));
    $ranking->setAttribute("desc", $2);
    $ranking->setAttribute("star", "1") if ($1 eq "ranking*");
    $ranking->setAttribute("date", $3) if (length($3));
    my $block = $ranking->appendChild(XML::LibXML::Element->new("block"));
    while(<$in>)
    {
	my $cref;
	my $sref;

	chomp $_;
	$_ =~ s:^[ ]+::;
	return if (m:^\\end\{ranking\*?\}:);

	if (m:^[ \t]*\\\\:)
	{
	    $block = $ranking->appendChild(XML::LibXML::Element->new("block"));
	    next;
	}
	next if (m:^[ \t]+$:);
	next if (m:^Total:);
	s/[ \t]*\\\\([ ]*\\hline)?$//;
	my ($name, $init, $sum, $em, $raw_ep, $ep, $time, $money) = split(/[ \t]*&[ \t]*/, $_);
	$name =~ s/ +$//;
	next if (!length($name));
	next if ($name =~ /\\hline/);

	my $type = "unknown";
	$name =~ s/\\and/\&amp\;/;
	$name =~ s/\\GTN/GTN/;
	$name =~ s/\\ITN/ITN/;

	if ($name =~ /^\\sref\{([A-Z]+)\}\{([A-Z0-9-]+)\}(.*)/)
	{
	    $cref = $1;
	    $sref = $2;
	    $name = $3;
	    $type = "talent" if ($sref =~ /T-[0-9]+/);
	    $type = "spell" if ($sref =~ /[GS]-([0-9]+|([GS]C))/);
	    $type = "ritual" if ($sref =~ /[QR]-[0-9]+/);
	}
	else
	{
	    $type = "stat" if ($name =~ /Physical Strength|Manual Dexturity|Agility|Magical Aptitude|Willpower|Endurance|Fatigue|Perception|Physical Beauty|Perception/);

	    $type = "language" if ($name =~ /Common|Elven|Dwarven|Silent tongue|lunar|children of the traveller|western human|orcish|pixie|pharoan|akadian|goblin|halfling|western tribal/i);

	    $type = "skill" if ($name =~ /Mechanician|Horsemanship|Swimming|Stealth|Climbing|Military Scientist|Weaponsmith|Ranger|Healer|Spy|Armourer|Flying|Warrior|thief|troubadour|Alchemist|Assassin|Merchant|Distiller|Courtesan|herbalist|artisan|Navigator|cook|astrologer|philosopher|Baker|Artisan (Cook)|brewer|glassblower|charcoaler|cooper/i);

	    $type = "weapon" if ($name =~ /Main gauche|Javelin|Broadsword|Crossbow|Dagger|Shield|Hand and a Half|Unarmed|Sabre|Battle axe|Mace|Scimitar|Quarterstaff|Spear|Cestus|Estoc|Glaive|Grenado|Great axe|sap|rapier|tulwar|short sword|two handed sword|rock|short bow|long bow|composite bow|garotte/i);

	    $type = "college" if ($name =~ /Namer/);
	    $type = "gtn" if ($name =~ /GTN$/);
	    $type = "itn" if ($name =~ /ITN$/);
	}

# --------------------
# Create XML Node
# --------------------

	my $skill = $block->appendChild(XML::LibXML::Element->new($type));
	$skill->setAttribute("name", $name);

	$skill->setAttribute("college", $cref) if (length($cref));
	$skill->setAttribute("ref", $sref) if (length($sref));

	if ($init =~ /upto/)
	{
	    my ($initial, $final) = split(/ ?\\upto ?/, $init);
	    $skill->setAttribute("initial", $initial);
	    $skill->setAttribute("final", $final);
	}
	else
	{
	    $skill->setAttribute("initial", $init);
	}

	my $track;
	my $partial = 0;
	if ($time =~ /(.*)\$\^\{?([0-9]+)(\\delta)?\}?\$/)
	{
	    $time = $1;
	    $track = $2;
	    $partial = 1 if ($3 eq "\\delta");

	}
	elsif ($time =~ /(.*)\$\^\{?(\\delta)\}?\$/)
	{
	    $time = $1;
	    $track = 0;
	    $partial = 1 if ($2 eq "\\delta");
	}
	else
	{
	    $track = 0;
	}

	$skill->setAttribute("sum", $sum) if (length($sum));
	$skill->setAttribute("em", $em) if (length($em));
	$skill->setAttribute("raw-ep", $raw_ep) if (length($raw_ep));
	$skill->setAttribute("ep", $ep) if (length($ep));
	$skill->setAttribute("time", $time) if (length($time));
	$skill->setAttribute("money", $money) if (length($money));
	$skill->setAttribute("track", $track) if (length($time) && !($time =~ /no time/i));
	$skill->setAttribute("partial", 1) if ($partial);
    }
}

sub DoExperience {
    my ($in, $adventure) = @@_;
    my @@items;
    my $count = 0;
    my $lcount = 0;

    do
    {
	for my $i (0 .. length($_) - 1)
	{
	    my $c = substr($_, $i, 1);
	    if ($c eq "{")
	    {
		$items[$count] .= $c if ($lcount);
		$lcount ++;
	    }
	    elsif ($c eq "}")
	    {
		$lcount--;
		$items[$count] .= $c if ($lcount);
		$count++ if ($lcount == 0);
	    }
	    elsif ($lcount > 0)
	    {
		$items[$count] .= $c;
	    }
	}
	$_ = <$in>;
    } while($count < 5);

    if (length($items[0]))
    {
	my $exp = $adventure->appendChild(XML::LibXML::Element->new("experience"));
	$exp->setAttribute("gained", $items[0]) if ($items[0]);
	$exp->setAttribute("in", $items[1]) if ($items[1]);
	$exp->setAttribute("spent", $items[2]) if ($items[2]);
	$exp->setAttribute("out", $items[3]) if (length($items[3]));
    }

    if (length($items[4]))
    {
	my $text = $items[4];
	$text =~ s/^\n//;
	my $note = $adventure->appendChild(XML::LibXML::Element->new("note"));
	$note->appendText($text);
    }
}

# ----------------------------------------------------------------------
#
# DoAdventure
#
# ----------------------------------------------------------------------

sub DoAdventure {
    my ($in, $root) = @@_;
    m/\\begin\{adventure(\*?)\}\{(.*)\}\{(.*)\}\{(.*)\}/;

    my $adventure = $root->addNewChild("", "adventure");
    $adventure->setAttribute("name", $2);
    $adventure->setAttribute("start", $3);
    $adventure->setAttribute("end", $4);
    $adventure->setAttribute("star", 1) if(length($1) || ($2 =~ /early life|life before the guild/i));

# --------------------
# Date work
# --------------------

    my $start = $adventure->getAttribute("start");
    my $end = $adventure->getAttribute("end");

    my $start_tick = new Tick($start);
    
    $adventure->setAttribute("start-tick", $start_tick);
    $adventure->setAttribute("end-tick", length($end) ? new Tick($end) : new Tick($start));

    while(<$in>)
    {
	&DoRanking($in, $adventure) if (m:^\\begin\{ranking\*?\}:);
	&DoAdventure($in, $root) if (m:^\\begin\{adventure\*?\}:);
	&DoExperience($in, $adventure) if (m:^\\experience:);
	&DoParty($in, $adventure) if (m:^\\begin\{party\}:);
	&DoMonies($in, $adventure) if (m:^\\begin\{monies\}:);
	&DoItems($in, $adventure) if (m:^\\begin\{items\}:);
    }
}



# ----------------------------------------------------------------------
#
# DoParty
#
# ----------------------------------------------------------------------

sub DoParty {
    my ($in, $adventure) = @@_;
    my $party = $adventure->appendChild(XML::LibXML::Element->new("party"));

    while (<$in>)
    {
	chomp $_;
	return if (m:^\\end\{party\}:);
	s/[ ]?\\\\$//;
	my ($name, $college, $note) = split(/[ \t]+?\&[ ]?/, $_);
	my $member = $party->appendChild(XML::LibXML::Element->new("member"));
	$member->setAttribute("name", $name);
	$member->setAttribute("college", $college);
	$member->setAttribute("note", $note) if (length($note));
    }
    return;
}

# ----------------------------------------------------------------------
#
# DoItems
#
# ----------------------------------------------------------------------

sub DoItems {
    my ($in, $adventure) = @@_;
    my $items = $adventure->appendChild(XML::LibXML::Element->new("items"));

    if (m/^\\begin\{items\}\{([A-Za-z0-9, ]+)\}/)
    {
	$items->setAttribute("desc", $1);
    }

    while (<$in>)
    {
	chomp $_;
	return if (m:^\\end\{items\}:);
	s/[ ]?\\\\$//;
	my $line = $items->appendChild(XML::LibXML::Element->new("line"));
	$line->setAttribute("desc", $_);
    }
    return;
}

# ----------------------------------------------------------------------
#
# Convert_Monies
#
# ----------------------------------------------------------------------

sub Convert_Monies {
    my ($in) = @@_;
    my $monies = {
	lines => []
    };
    my $date;

    if (m/^\\begin\{monies\}\[([A-Za-z ]+)\]\{(-?[0-9]+)\}\{(-?[0-9]+)\}\{([A-Za-z0-9\/,\. ]+)\}/)
    {
	$monies->{ledger} = $1;
	$monies->{in} = $2;
	$monies->{out} = $3;
	$monies->{date} = $4;
	$date = $4;
    }
    elsif (m/^\\begin\{monies\}\{(-?[0-9]+)\}\{(-?[0-9]+)\}\{([A-Za-z0-9\/,\. ]+)\}/)
    {
	$monies->{in} = $1;
	$monies->{out} = $2;
	$monies->{date} = $3;
	$date = $3;
    }
    $monies->{tick} = new Tick($date);

    while (<$in>)
    {
	chomp $_;
	return $monies if (m:^\\end\{monies\}:);
	s/[ ]?\\\\([ ]?(\\hline)?)$//;
	my ($desc, $out, $in) = split(/[ \t]+?\&[ ]?/, $_);
	my $line = {};
	$line->{desc} = $desc;
	$line->{out} = $out if (length($out));
	$line->{in} = $in if (length($in) && !length($out));
	push(@@{$monies->{lines}}, $line);
    }
}

# ----------------------------------------------------------------------
#
# Convert_Ranking
#
# ----------------------------------------------------------------------

sub Convert_Ranking {
    my ($in) = @@_;

    my $ranking = {};
    
    if (m:\\begin\{(ranking\*?)\}\{(.*)\}\{(.*)\}:)
    {
	$ranking->{desc} =  $2;
	$ranking->{star} = 1 if ($1 eq "ranking*");
	$ranking->{date} = $3 if (length($3));
    }
    elsif (m:\\begin\{(ranking\*?)\}\{(.*)\}:)
    {
	$ranking->{desc} =  $2;
	$ranking->{star} = 1 if ($1 eq "ranking*");
    }
    else
    {
	print STDERR "Bad ranking line $_\n";
	return undef;
    }

    my $block = {
	lines => []
    };

    while(<$in>)
    {
	my $cref;
	my $sref;

	chomp $_;
	$_ =~ s:^[ ]+::;
	last if (m:^\\end\{ranking\*?\}:);

	if (m:^[ \t]*\\\\:)
	{
	    push(@@{$ranking->{blocks}}, $block) if(defined($block));
	    $block = { lines => [] };
	    next;
	}
	next if (m:^[ \t]+$:);
	next if (m:^Total:);
	s/[ \t]*\\\\([ ]*\\hline)?$//;
	my ($name, $init, $sum, $em, $raw_ep, $ep, $time, $money) = split(/[ \t]*&[ \t]*/, $_);
	$name =~ s/ +$//;
	next if (!length($name));
	next if ($name =~ /\\hline/);

	my $type = "unknown";
	$name =~ s/\\and/\&amp\;/;
	$name =~ s/\\GTN/GTN/;
	$name =~ s/\\ITN/ITN/;

	if ($name =~ /^\\sref\{([A-Z]+)\}\{([A-Z0-9-]+)\}(.*)/)
	{
	    $cref = $1;
	    $sref = $2;
	    $name = $3;
	    $type = "talent" if ($sref =~ /T-[0-9]+/);
	    $type = "spell" if ($sref =~ /[GS]-([0-9]+|([GS]C))/);
	    $type = "ritual" if ($sref =~ /[QR]-[0-9]+/);
	}
	else
	{
	    $type = "stat" if ($name =~ /Physical Strength|Manual Dexturity|Agility|Magical Aptitude|Willpower|Endurance|Fatigue|Perception|Physical Beauty|Perception/);

	    $type = "language" if ($name =~ /Common|Elven|Dwarven|Silent tongue|lunar|children of the traveller|western human|orcish|pixie|pharoan|akadian|goblin|halfling|western tribal/i);

	    $type = "skill" if ($name =~ /Mechanician|Horsemanship|Swimming|Stealth|Climbing|Military Scientist|Weaponsmith|Ranger|Healer|Spy|Armourer|Flying|Warrior|thief|troubadour|Alchemist|Assassin|Merchant|Distiller|Courtesan|herbalist|artisan|Navigator|cook|astrologer|philosopher|Baker|Artisan (Cook)|brewer|glassblower|charcoaler|cooper/i);

	    $type = "weapon" if ($name =~ /Main gauche|Javelin|Broadsword|Crossbow|Dagger|Shield|Hand and a Half|Unarmed|Sabre|Battle axe|Mace|Scimitar|Quarterstaff|Spear|Cestus|Estoc|Glaive|Grenado|Great axe|sap|rapier|tulwar|short sword|two handed sword|rock|short bow|long bow|composite bow|garotte/i);

	    $type = "college" if ($name =~ /Namer/);
	    $type = "gtn" if ($name =~ /GTN$/);
	    $type = "itn" if ($name =~ /ITN$/);
	}

# --------------------
# Create line
# --------------------

	my $line = {};
	$line->{name} = $name;
	$line->{college} = $cref if (length($cref));
	$line->{ref} = $sref if (length($sref));

	if ($init =~ /upto/)
	{
	    my ($initial, $final) = split(/ ?\\upto ?/, $init);
	    $line->{initial} = $initial;
	    $line->{final} = $final;
	}
	else
	{
	    $line->{initial} = $init;
	}

	my $track;
	my $partial = 0;
	if ($time =~ /(.*)\$\^\{?([0-9]+)(\\delta)?\}?\$/)
	{
	    $time = $1;
	    $track = $2;
	    $partial = 1 if ($3 eq "\\delta");

	}
	elsif ($time =~ /(.*)\$\^\{?(\\delta)\}?\$/)
	{
	    $time = $1;
	    $track = 0;
	    $partial = 1 if ($2 eq "\\delta");
	}
	else
	{
	    $track = 0;
	}

	$time = undef if ($time =~ m:no time:i);

	$line->{type} = $type;
	$line->{sum} = $sum if (length($sum));
	$line->{em} = $em if (length($em));
	$line->{raw_ep} = $raw_ep if (length($raw_ep));
	$line->{ep} = $ep if (length($ep));
	$line->{time} = $time if (length($time));
	$line->{money} = $money if (length($money));
	$line->{track} = $track if (length($track));
	$line->{partial} = $partial if (length($partial));
	push(@@{$block->{lines}}, $line);
    }
    push(@@{$ranking->{blocks}}, $block);
    return $ranking;
}

# ----------------------------------------------------------------------
#
# Convert_Experience
#
# ----------------------------------------------------------------------

sub Convert_Experience {
    my ($in) = @@_;
    my @@items;
    my $count = 0;
    my $lcount = 0;

    do
    {
	for my $i (0 .. length($_) - 1)
	{
	    my $c = substr($_, $i, 1);
	    if ($c eq "{")
	    {
		$items[$count] .= $c if ($lcount);
		$lcount ++;
	    }
	    elsif ($c eq "}")
	    {
		$lcount--;
		$items[$count] .= $c if ($lcount);
		$count++ if ($lcount == 0);
	    }
	    elsif ($lcount > 0)
	    {
		$items[$count] .= $c;
	    }
	}
	$_ = <$in> if ($count < 5);
    } while($count < 5);

    my $exp = {};

    if (length($items[0]))
    {
	$exp->{gained} = $items[0] if ($items[0]);
	$exp->{in} = $items[1] if($items[1]);
	$exp->{spent} = $items[2] if ($items[2]);
	$exp->{out} =  $items[3] if (length($items[3]));
    }
    
    if (length($items[4]))
    {
	my $text = $items[4];
	$text =~ s/^\n//;
	$exp->{notes} = $text;
    }
    return $exp;
}

# ----------------------------------------------------------------------
#
# Convert_Party
#
# ----------------------------------------------------------------------

sub Convert_Party {
    my ($in, $adventure) = @@_;

    my $party = $adventure->{party} = {};

    while (<$in>)
    {
	chomp $_;
	return if (m:^\\end\{party\}:);
	s/[ ]?\\\\$//;
	my ($name, $college, $note) = split(/[ \t]+?\&[ ]?/, $_);
	my $member = {
	    name => $name,
	    college => $college
	};
	$member->{note} = $note if (length($note));
	push(@@{$party->{members}}, $member);
    }
    return;
}

# ----------------------------------------------------------------------
#
# Convert_Adventure
#
# ----------------------------------------------------------------------

sub Convert_Adventure {
    my ($in) = @@_;
    m/\\begin\{adventure(\*?)\}\{(.*)\}\{(.*)\}\{(.*)\}/;

    my $adventure = {};
    
    $adventure->{name} = $2;
    $adventure->{start} = $3;
    $adventure->{end} = $4;
    $adventure->{star} = 1 if(length($1));
    $adventure->{ranking} = [];
    $adventure->{monies} = [];
   
    # --------------------
    # Date work
    # --------------------

    my $start = $adventure->{"start"};
    my $end = $adventure->{"end"};

    my $start_tick = new Tick($start);
    
    $adventure->{start_tick} = $start_tick;
    $adventure->{end_tick} = length($end) ? new Tick($end) : new Tick($start);
    
    while(<$in>)
    {
	chomp $_;
	if (m:^\\end\{adventure\}:)
	{
	    return $adventure;
	}
	if (m:^\\begin\{ranking\*?\}:)
	{
	    my $ranking = &Convert_Ranking($in);
	    push(@@{$adventure->{ranking}}, $ranking) if ($ranking);
	}
	if (m:^\\experience:)
	{
	    my $exp = &Convert_Experience($in);
	    $adventure->{experience} = $exp;
	}
	if (m:^\\begin\{monies\}:)
	{
	    my $monies = &Convert_Monies($in) ;
	    push(@@{$adventure->{monies}}, $monies) if (defined($monies));
	}
	&Convert_Party($in, $adventure) if (m:^\\begin\{party\}:);
	#	&DoItems($in, $adventure) if (m:^\\begin\{items\}:);
    }
    return undef;
}

# ----------------------------------------------------------------------
#
# XML_Adventure
#
# ----------------------------------------------------------------------

sub XML_Adventure {
    my ($root, $adventure) = @@_;

    my $node = $root->addNewChild('', 'adventure');

    for my $k ('name', 'start', 'end', 'star', 'start_tick', 'end_tick')
    {
	if (exists($adventure->{$k}))
	{
	    my $xk = $k;
	    $xk =~ s:_:-:g;
	    $node->setAttribute($xk, $adventure->{$k});
	}
    }

    # --------------------
    # Party
    # --------------------
    
    if (my $p = $adventure->{party})
    {
	my $party = $node->addNewChild('', 'party');
	for my $m (@@{$p->{members}})
	{
	    assert($m->{name});
	    assert($m->{college});

	    my $member = $party->addNewChild('', 'member');
	    $member->setAttribute('name', $m->{name});
	    $member->setAttribute('college', $m->{college});
	}
    }

    # --------------------
    # Ranking
    # --------------------
	
    for my $r (@@{$adventure->{ranking} || []})
    {
	my $ranking = $node->addNewChild('', 'ranking');

	$ranking->setAttribute("desc", $r->{desc});
	$ranking->setAttribute("star", "1") if ($r->{star});
	$ranking->setAttribute("start", $r->{start}->CDate()) if ($r->{start});
	$ranking->setAttribute("end", $r->{end}->CDate()) if ($r->{end});

	for my $b (@@{$r->{blocks}})
	{
	    
	    my $block = $ranking->addNewChild('', 'block');
	    $block->setAttribute("time", $b->{time}) if ($b->{time});

# --------------------
# Create XML Node
# --------------------

	    for my $l (@@{$b->{lines} || []})
	    {
		my $skill = $block->addNewChild('', $l->{type});
		$skill->setAttribute("name", $l->{name});

		$skill->setAttribute("college", $l->{college}) if ($l->{college});
		$skill->setAttribute("ref", $l->{sref}) if ($l->{sref});

		$skill->setAttribute("initial", $l->{initial});
		$skill->setAttribute("final", $l->{final}) if ($l->{final});

		$skill->setAttribute("sum", $l->{sum}) if ($l->{sum});
		$skill->setAttribute("em", $l->{em}) if ($l->{em});
		$skill->setAttribute("raw-ep", $l->{raw_ep}) if ($l->{raw_ep});
		$skill->setAttribute("ep", $l->{ep}) if ($l->{ep});
		$skill->setAttribute("time", $l->{time}) if ($l->{time});
		$skill->setAttribute("money", $l->{money}) if ($l->{money});
		$skill->setAttribute("track", $l->{track}) if ($l->{time}); # length($time) && !($time =~ /no time/i));
		$skill->setAttribute("partial", 1) if ($l->{partial});
	    }
	}  
    }

    if (my $e = $adventure->{experience})
    {
	my $exp = $node->addNewChild('', 'experience');
	$exp->setAttribute("gained", $e->{gained}) if ($e->{gained});
	$exp->setAttribute("in", $e->{in}) if ($e->{in});
	$exp->setAttribute("spent", $e->{spent}) if ($e->{spent});
	$exp->setAttribute("out", $e->{out}) if ($e->{out});
    }
}

# ----------------------------------------------------------------------
#
# XML_Character
#
# ----------------------------------------------------------------------

sub XML_Character {
    my ($conf, $character) = @@_;

    my $state = $character->{_state_};
    my $map = $character->{_map_};
    
    # --------------------
    # Create XML document
    # --------------------
    
    my $doc = XML::LibXML::Document->new("1.0", "UTF-8");
    my $root = $doc->createElement("character");
    $doc->setDocumentElement($root);
    $root->setAttribute("system", "dq");
    my $basics = XML::LibXML::Element->new("basics"); $root->appendChild($basics);

    for my $k ('charname', 'fullname', 'race', 'college', 'status', 'sex', 'height', 'weight', 'aspect', 'hand', 'birth', 'date', 'dateofbirth')
    {
	$basics->setAttribute($k, $character->{basics}->{$k}) if ($character->{basics}->{$k});
    }

    # --------------------
    # Start updating the current values
    # --------------------
    
    $basics->setAttribute("ep-total", $state->{"ep_total"});
    $basics->setAttribute("ep", $state->{"ep"});

    my $tick = new Tick($basics->getAttribute('date'));
    
    $basics->setAttribute("date", $state->{'tick'}->CDate());
    $basics->setAttribute("tick", $state->{'tick'}->{tick});
    $basics->setAttribute("calendar", $tick->{calendar});
    
    my @@clist = $root->findnodes("current")->get_nodelist();
    if (scalar(@@clist))
    {
	$clist[0]->unbindNode();
    }
    my $current = $doc->createElement("current");
    if ($current)
    {
	$root->insertAfter($current, $basics);
	my $stats = $current->addChild($doc->createElement("stats"));
	my $statmap = {
	    'PS'	=> 'Physical Strength',
	    'MD'	=> 'Manual Dexturity',
	    'AG'	=> 'Agility',
	    'MA'	=> 'Magical Aptitude',
	    'WP'	=> 'Willpower',
	    'EN'	=> 'Endurance',
	    'FT'	=> 'Fatigue',
	    'PB'	=> 'Physical Beauty',
	    'PC'	=> 'Perception',
	};
	for my $i ('PS', 'MD', 'AG', 'MA', 'WP', 'EN', 'FT', 'PB', 'PC')
	{
	    my $s = $stats->addChild($doc->createElement("stat"));
	    $s->setAttribute("name", $i);
	    $s->setAttribute("value", $map->{'stat'}->{$statmap->{$i}}->{"rank"});
	}
    }

# --------------------
# Do skills, languages and weapons
# --------------------

    my $slw = {
	'skill' => {
	    'parent'	=> 'skills',
	    'child'	=> 'skill',
	},
	'language' => {
	    'parent'	=> 'languages',
	    'child'	=> 'language',
	},
	'weapon' => {
	    'parent'	=> 'weapons',
	    'child'	=> 'weapon',
	},
	'talent' => {
	    'parent'	=> 'talents',
	    'child'	=> 'talent',
	},
	'spell' => {
	    'parent'	=> 'spells',
	    'child'	=> 'spell',
	},
	'ritual' => {
	    'parent'	=> 'rituals',
	    'child'	=> 'ritual',
	},
    };

# --------------------
# Add current values
# --------------------

    for my $i (keys(%{$slw}))
    {
	my $xmap = $map->{$i};

	my @@list = sort({$xmap->{$b}->{"rank"} <=> $xmap->{$a}->{"rank"}} grep(!m:^__:, keys(%$xmap)));

	if (scalar(@@list))
	{
	    my $parent = $current->addChild($doc->createElement($slw->{$i}->{'parent'}));
	    for my $j (@@list)
	    {
		next if ($j =~ m/^__/);
		my $child = $doc->createElement($slw->{$i}->{'child'});
		$child->setAttribute("name", $j);
		$child->setAttribute("rank", $xmap->{$j}->{'rank'});
		$child->setAttribute("ref", $xmap->{$j}->{'ref'}) if (exists $xmap->{$j}->{'ref'});
		$child->setAttribute("college", $xmap->{$j}->{'college'}) if (exists $xmap->{$j}->{'college'});
		$parent->appendChild($child);
	    }
 	}
    }

    # --------------------
    # Iterate over adventures
    # --------------------

    for my $a (@@{$character->{adventures}})
    {
	&XML_Adventure($root, $a);
    }
    
    # --------------------
    # Output XML
    # --------------------
    
    if ($conf->{outfile})
    {
	$doc->toFile($conf->{outfile}, 1);
    }
    else
    {
	print $doc->toString(1);
    }
}

# ----------------------------------------------------------------------
#
# JSON_Character
#
# ----------------------------------------------------------------------

sub JSON_Character {
    my ($opts, $character) = @@_;

    my $stream;
    if ($opts->{outfile})
    {
	open($stream, ">", $opts->{outfile});
    }
    else
    {
	$stream = \*STDOUT;
    }
    print $stream to_json($character, {pretty=>1, convert_blessed=>1});
}

# ----------------------------------------------------------------------
#
# Main
#
# ----------------------------------------------------------------------

sub Main {
    my $opts = {};

    my ($in, $out);

    my %opts;
    GetOptions(
	'encoding=s' => \$opts->{'codepage'},
	'in=s' => \$opts->{'infile'},
	'out=s' => \$opts->{'outfile'},
	'format=s' => \$opts->{'format'}
	);
    
    my $codepage = $opts->{'codepage'} // 'utf8';
    if ($opts->{"infile"})
    {
	open(IN, "<:encoding($codepage)", $opts->{"infile"}) || die "Cannot open file.";
	$in = \*IN;
    }
    else
    {
	$in = \*STDIN;
    }

    # --------------------
    # Base JS object
    # --------------------
    
    my $character = {};
    my $basics = $character->{basics} = {};
    
    while(<$in>)
    {
	chomp $_;
	$basics->{player} = $1 if (m:^\\player\{(.*)\}:);
	$basics->{charname} = $1 if (m:^\\charname\{(.*)\}:);
	$basics->{fullname} = $1 if (m:^\\fullname\{(.*)\}:);
	$basics->{race} = $1 if (m:^\\race\{(.*)\}:);
	$basics->{college} = $1 if (m:^\\college\{(.*)\}:);
	$basics->{status} = $1 if (m:^\\status\{(.*)\}:);
	$basics->{sex} = $1 if (m:^\\sex\{(.*)\}:);
	$basics->{height} = $1 if (m:^\\height\{(.*)\}:);
	$basics->{weight} = $1 if (m:^\\weight\{(.*)\}:);
	$basics->{aspect} = $1 if (m:^\\aspect\{(.*)\}:);
	$basics->{hand} = $1 if (m:^\\hand\{(.*)\}:);
	$basics->{birth} = $1 if (m:^\\birth\{(.*)\}:);
	$basics->{date} = $1 if (m:^\\date\{(.*)\}:);
	$basics->{dateofbirth} = $1 if (m:^\\dateofbirth\{(.*)\}:);

	if (m:^\\begin\{adventure\*?\}:)
	{
	    my $adventure = &Convert_Adventure($in) ;
	    push(@@{$character->{adventures}}, $adventure) if ($adventure);
	}
    }

    my $f_map = {
	'xml' => \&XML_Character,
	    'json' => \&JSON_Character,
	    'plain' =>\&Plain_Chacter,
    };

    &Update_Character($opts, $character);

    if ($f_map->{$opts->{'format'}})
    {
	$f_map->{$opts->{'format'}}->($opts, $character);
    }
}

&Main();
@


1.6
log
@Summary: Remove cruft.
@
text
@d3 11
d15 1
a15 1
use Getopt::Std;
d19 3
a21 1
use 5.20.1;
d25 1
a25 1
# DqDate
a27 51
sub DqDate {
    my ($date) = @@_;

    my $mm = {
	'january' => 0,
	'february' => 1,
	'march' => 2,
	'april' => 3,
	'may' => 4,
	'june' => 5,
	'july' => 6,
	'august' => 7,
	'september' => 8,
	'october' => 9,
	'november' => 10,
	'december' => 11,

	'meadow' => 0,
	'heat' => 1,
	'breeze' => 2,
	'fruit' => 3,
	'harvest' => 4,
	'vintage' => 5,
	'frost' => 6,
	'snow' => 7,
	'ice' => 8,
	'thaw' => 9,
	'seedtime' => 10,
	'blossom' => 11,

	'lebh' => 0,
	'life' => 0,
	'khomets' => 1,
	'bread' => 1,
	'porekh' => 2,
	'dust' => 2,
	'ov' => 3,
	'ancestor' => 3,
	'toyt' => 4,
	'death' => 4,
	'vint' => 5,
	'wind' => 5,
	'kindheyt' => 6,
	'childhood' => 6,
	'shakhres' => 7,
	'prayer' => 7,
	'brenen' => 8,
	'burning' => 8,
	'mablen' => 9,
	'rain' => 9 
    };
d29 8
a36 10
    my $mq = {
	'beltane' => 0,
	'spring' => 0,
	'lugnasad' => 3,
	'summer' => 3,
	'samhain' => 6,
	'autumn' => 6,
	'candlemansa' => 9,
	'winter' => 9,
    };
d39 1
a39 1
    # allocate locals
d41 4
a45 2
    my ($day, $hmonth, $month, $year, $calandar);

d47 1
a47 1
    # Split date
d50 1
a50 2
    my @@bits = split(/[ ,\.\/]+/, $date);
    if (scalar(@@bits) < 3)
d52 30
a81 2
	printf(STDERR "Incorrect date %s.\n", $date);
	exit 1;
d85 1
a85 1
    # Last part always the calandar
d87 5
a91 2
	
    $calandar = pop(@@bits);
d93 1
a93 1
    if (!($calandar eq "AP" || $calandar eq "WK" || $calandar eq "CM"))
d95 6
a100 1
	print STDERR "Known calandar \'$calandar\' in date \'$date\'.\n";
d105 7
a111 1
    # See if it is Communique Mercantile
d113 2
d116 1
a116 1
    if ($calandar eq "CM")
d118 2
a119 2
	$year = pop(@@bits);
	if (!($year =~ m:^[0-9]+$:))
d121 138
a258 12
	    print STDERR "Unknown CM year $year.\n";
	    exit 1;
	}
	$month = pop(@@bits);
	$month =~ tr:A-Z:a-z:;
	if (! exists($mm->{$month}))
	{
	    print STDERR "Unknown month $month in $date.\n";
	    exit 1;
	}
	$hmonth = pop(@@bits);
	$hmonth =~ tr:A-Z:a-z:;
d260 1
a260 17
	if ($hmonth eq "aroplezn" || $hmonth eq "lower")
	{
	    $month *= 2;
	}
	elsif ($hmonth eq "ariber" || $hmonth eq "upper")
	{
	    $month *=2 + 1;
	}
	else
	{
	    print STDERR "CM date missing upper/lower indicator.\n";
	    exit 1;
	}
	if (scalar(@@bits))
	{
	    $day = pop(@@bits);
	    if (!$day =~ m:^[0-9]+$:)
d262 1
a262 1
		print STDERR "Day $day not a number.\n";
d265 1
a265 6
	else
	{
	    $day = 1;
	}
	my $tick = $year * 400 + $month * 20 + $day;
	return ($tick, $calandar);
d269 1
a269 1
    # Otherwise it is AP or WK
d271 3
a273 2
    
    else
d275 9
a283 1
	if ($bits[0] =~ /[A-Za-z]+/)
d285 2
a286 2
	    $month = $bits[0];
	    $day = $bits[1];
d288 4
a291 1
	elsif ($bits[1] =~ /[A-Za-z]+/)
d293 2
a294 2
	    $month = $bits[1];
	    $day = $bits[0];
d296 1
a296 1
	else
d298 2
a299 2
	    $day = $bits[0];
	    $month = $bits[1];
d301 75
a375 23
	if ($month =~ /[A-Za-z]+/)
	{
	    my $t = lc($month);
	    if (exists($mq->{$t}))
	    {
		$month = $mq->{$t};
		$day = 0;
	    }
	    elsif (!exists($mm->{$t}))
	    {
		print STDERR "Unknown month \'$t\' in \'$date\'.\n";
		exit(1);
	    }
	    else
	    {
		$month = $mm->{$t};
	    }
	}
	else
	{
	    $month -= 1;
	}
	$year = pop(@@bits);
d377 3
a379 21
#	print "++ $day $month $year $calandar\n";
	
	my $tick;
	if ($calandar eq "AP")
	{
	    $year += 1900 if ($year < 100);
	    
	    my @@md = (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334);
	    $tick += ($year - 1970) * 364;
	    $tick += $md[$month];
	    $tick += $day - 1;
	    $tick += 273;
	}
	else
	{
	    my @@md = (1, 31, 61, 92, 122, 152, 183, 213, 243, 274, 304, 334);
	    $tick += ($year - 770) * 364;
	    $tick += $md[$month];
	    $tick += $day - 1;
	}
	return ($tick, $calandar);
d381 3
d463 4
a466 3
    my ($tick, $calandar) = DqDate($date);
    $monies->setAttribute("tick", $tick);
    $monies->setAttribute("calandar", $calandar);
a478 1
    return;
d490 1
d657 1
a657 1
    my $adventure = $root->appendChild(XML::LibXML::Element->new("adventure"));
d670 4
a673 1
    my ($start_tick, $start_cal) = &DqDate($start);
a674 4
    $adventure->setAttribute("start-tick", $start_tick);
    $adventure->setAttribute("end-tick", length($end) ? &DqDate($end) : &DqDate($start));
    $adventure->setAttribute("calandar", $start_cal);
    
a682 4

#	print $adventure->toString(1);
#	print "\n\n--------------------------\n\n";

d687 1
d690 1
a690 1
# XML_Adventure
d694 3
a696 1
sub XML_Adventure {
d698 13
a710 1
    my ($map, $state, $adventure) = @@_;
d712 5
a716 1
# Print out adventure name
d718 3
a720 7
    my $tick = $state->{'tick'};
    my $start = $adventure->getAttribute("start-tick");
    my $end = $adventure->getAttribute("end-tick");
    my $cal = $adventure->getAttribute("calandar");
    assert($cal);
    
    printf("** %s [%s - %s] **\n\n", $adventure->getAttribute("name"), &TickToCDate($start, $cal), &TickToCDate($end, $cal));
d722 4
a725 3
# --------------------
# Process Money
# --------------------
d727 1
a727 1
    for my $m ($adventure->findnodes("monies")->get_nodelist)
d729 8
a736 3
	next if $m->hasAttribute("desc");
	my $in = $m->getAttribute("in");
	my $out = 0;
d738 5
a742 3
# --------------------
# Check "in" is correct.
# --------------------
d744 6
a749 5
	if ($state->{"money"} != $in)
	{
	    print "Money computed value different from stored value (", $state->{"money"}, " vs $in).\n";
	    exit(1);
	}
d751 16
a766 5
	for my $l ($m->findnodes("line")->get_nodelist)
	{
	    $in += $l->getAttribute("in") if ($l->hasAttribute("in"));
	    $out += $l->getAttribute("out") if ($l->hasAttribute("out"));
	}
d768 13
a780 2
	my $total = $in - $out;
	my $amount = $m->getAttribute("out");
d782 5
a786 7
	if ($amount != $total)
	{
	    print STDERR "Error in money dated ", $m->getAttribute("date"), " ($amount vs $total).\n";
	    exit(1);
	}
	$state->{"money"} = $amount;
    }
d788 2
a789 3
# --------------------
# Check Dates
# --------------------
d791 9
a799 1
    if ($tick > $start)
d801 2
a802 2
	printf STDERR "Serious start date issue (Current %s Start %s)!\n", &TickToWK($tick), &TickToWK($start);
	exit 1;
d804 1
a804 1
    if ($start > $end)
d806 2
a807 2
	printf STDERR "Serious date issue!\n";
	exit 1;
a808 1
    $tick = $end + 1;
d810 3
a812 3
# --------------------
# Iterate over all the ranking nodes
# --------------------
d814 1
a814 1
    for my $ranking ($adventure->findnodes("ranking")->get_nodelist)
d816 2
a817 3
	$ranking->setAttribute("start", $tick);
	for my $block ($ranking->findnodes("block")->get_nodelist)
	{
d819 3
a821 1
# Set block level ep and time counters to zero.
d823 13
a835 2
	    my $block_ep = 0;
	    my @@time = (0, 0, 0);
d837 4
a840 1
# Iterate over every ranking line in the block.
d842 12
a853 2
	    for my $node ($block->findnodes("child::*")->get_nodelist)
	    {
d855 1
a855 1
# Get the type ie skill, spell, ritual, etc.
d857 1
a857 1
		my $type = $node->getName();
d859 1
a859 1
# Make sure valid entry.
d861 4
a864 5
		if (!exists $map->{$type})
		{
		    print STDERR "Type $type unknown -- exiting.\n";
		    exit 1;
		}
d866 3
a868 1
		my $name = $node->getAttribute("name");
d870 4
a873 5
		if ((!$node->hasAttribute("initial") || !length($node->getAttribute("initial"))) && $map->{"type"}->{"__rankable__"}) 
		{
		    print STDERR "$type $name does not have initial value.\n";
		    exit 1;
		}
d875 10
a884 1
# Create hash entry if it don't already exist.
d886 7
a892 2
		$map->{$type}->{$name} = {} if (!exists $map->{$type}->{$name});
		$map->{$type}->{$name}->{'name'} = $name;
d894 11
a904 2
		$map->{$type}->{$name}->{'college'} = $node->getAttribute("college") if ($node->hasAttribute("college"));
		$map->{$type}->{$name}->{'ref'} =  $node->getAttribute("ref") if ($node->hasAttribute("ref"));
d906 1
a906 4
		my $initial = $node->getAttribute("initial");
		my $final = $node->getAttribute("final");
		my $rank = $map->{$type}->{$name}->{'rank'};
		my $partial = $node->getAttribute("partial");
d908 14
a921 5
		if (exists($map->{$type}->{$name}->{'rank'}) && !$partial && ($rank ne $initial))
		{
		    printf "$type $name initial [%s] not same as current rank [%s]\n", $initial, $rank;
		    exit(1);
		}
d923 5
a927 1
# Having got the initial ranking value its now time to get the final.
d929 5
a933 9
		if ($node->hasAttribute("final") && !$partial)
		{
		    my $old = $map->{$type}->{$name}->{"rank"};
		    $map->{$type}->{$name}->{"rank"} = $final;
		}
		else
		{
		    $map->{$type}->{$name}->{"rank"} = $initial;
		}
d935 23
a957 3
# --------------------
# Check values
# --------------------
d959 1
a959 43
		my ($em, $cep, $ep, $rep, $sum, $diff, $csum);
		
		if ($node->hasAttribute("initial") && $node->hasAttribute("final"))
		{
		    $initial = 0 if ($initial eq "U" && ($final > 0));
		    if ($initial ne "U")
		    {
			$sum = $node->getAttribute("sum");
			$csum = ($node->getName() eq "stat") ?
			    $final - $initial :
			    (($final * ($final + 1)) - ($initial * ($initial +1))) / 2;
		    
			if ($csum != $sum)
			{
			    print "Initial = $initial  Final = $final  sum = $csum (sum = $sum).\n";
			    print $node->toString(1), "\n";
			    exit(1);
			}
			if ($node->hasAttribute("em"))
			{
			    $em = $node->getAttribute("em");
			    $cep = $sum * $em;
			    $ep = $node->hasAttribute("raw-ep") ?
				$node->getAttribute("raw-ep") :
				$node->getAttribute("ep");
			    if ($cep != $ep)
			    {
				print "EP = $ep -- computed EP $sum * $em = $cep\n";
				print $node->toString(1), "\n";
				exit(1);
			    }
			}
			if ($node->hasAttribute("ep") && $node->hasAttribute("raw-ep"))
			{
			    $ep = $node->getAttribute("ep");
			    $rep = $node->getAttribute("raw-ep");
			    $diff = ($rep >= $ep) ? $ep / $rep : $ep / $rep;
			}
		    }
		}
# --------------------
# Process time and EP
# --------------------
d961 16
a976 8
		my $time_str = $node->getAttribute("time");
		$time_str =~ /([0-9]+) (day|days|week|weeks)/;
		my $time = $1;
		$time *= 7 if (($2 eq "week") || ($2 eq "weeks"));
		my $track = $node->getAttribute("track");
		$node->setAttribute("day-equiv", $time);
		$time[$track] += $time;
		$block_ep += $node->getAttribute("ep");
d978 5
a982 5
		printf("%s (%s..%s)\t Raw EP = %d EP = %d Diff = %4.2f : Time = %s\n",
		       $name, $initial, $final,
		       $rep, $ep, $diff, $time);
	    }
	    $block->setAttribute("ep", $block_ep);
d984 2
a985 3
# --------------------
# sort the time tracks to get maximum
# --------------------
d987 1
a987 4
	    print "Track times = ", join(" : ", @@time), "\n";
	    my @@tsort = sort { $a <=> $b } @@time;
	    $block->setAttribute("start", $tick);
	    $block->setAttribute("time", $tsort[$#tsort]);
d989 12
a1000 6
	    if (!($ranking->hasAttribute("star") && ($ranking->getAttribute("star") > 0)))
	    {
		$tick += $tsort[$#tsort];
	    }
	}
	$ranking->setAttribute("end", $tick);
d1002 2
d1005 9
a1013 3
# --------------------
# Process total Experience
# --------------------
d1015 12
a1026 7
    my $exp = $adventure->findnodes("experience")->[0];
    if (defined $exp)
    {
	my $ep_in = $exp->getAttribute("in");
	my $ep_gained = $exp->getAttribute("gained");
	my $ep_spent = $exp->getAttribute("spent");
	my $ep_out = $exp->getAttribute("out");
d1028 2
a1029 2
	$state->{"ep-total"} += $ep_gained;
	my $in = $state->{"ep"};
d1031 13
a1043 1
	if ($in != $ep_in)
d1045 2
a1046 2
	    print STDERR "Recorded transferred EP ($ep_in) is different from computed value ($in).\n";
	    exit(1);
d1048 1
a1048 4

	my $spent = $adventure->find('sum(ranking/block/@@ep)');
	my $out = $in + $ep_gained - eval($spent);
	if ($spent != $ep_spent)
d1050 2
a1051 2
	    print STDERR "Recorded spent EP ($ep_spent) is different from computed value ($spent) [remaining $ep_out vs $out].\n";
	    exit(1);
d1053 1
a1053 1
	if ($out != $ep_out)
d1055 2
a1056 2
	    print STDERR "Recorded remaining EP ($ep_out) is different from computed value ($out).\n";
	    exit(1);
d1058 2
a1059 4
	$state->{"ep"} = $out;
	$state->{"tick"} = $tick;

	printf("EP:in %d gained %d spent %d out %d\n", $ep_in, $ep_gained, $ep_spent, $ep_out);
d1061 1
a1061 2
    printf("Time: start %s - end %s - current %s [%d]\n", TickToCDate($start, $cal), TickToCDate($end, $cal), TickToCDate($tick, $cal), $tick - $end);
    printf("\n");
d1066 1
a1066 1
# XML_File
d1070 32
a1101 1
sub XML_Update {
d1103 7
a1109 1
    my ($conf, $doc) = @@_;
d1111 4
a1114 1
# Get root element (<character>).
d1116 5
a1120 1
    my $root = $doc->getDocumentElement();
d1122 3
a1124 1
# Create reference to a hash which hold ranking values.
d1126 7
a1132 32
    my $map = {
	'college' => {
	    '__rankable__' => 0,
	},
	'stat' => {
	    '__rankable__' => 1,
	},
	'weapon' => {
	    '__rankable__' => 1,
	},
	'skill' => {
	    '__rankable__' => 1,
	},
	'language' => {
	    '__rankable__' => 1,
	},
	'talent' => {
	    '__rankable__' => 1,
	},
	'spell' => {
	    '__rankable__' => 1,
	},
	'ritual' => {
	    '__rankable__' => 1,
	},
	'itn' => {
	    '__rankable__' => 1,
	},
	'gtn' => {
	    '__rankable__' => 1,
	},
    };
d1134 2
a1135 2
# Create refernece to a hash which holds state and values to pass
# between adventures.
d1137 11
a1147 6
    my $state = {
	'money' => 0,
	'ep' => 0,
	'ep-total' => 0,
	'tick' => 0
    };
d1149 9
a1157 1
    $map->{'state'} = $state;
d1159 5
a1163 1
# Iterate over every adventure and process sequentially.
d1165 2
a1166 3
    map {
	&XML_Adventure($map, $state, $_);
    } ($root->findnodes("adventure")->get_nodelist);
d1168 12
a1179 3
# --------------------
# Get the basics node
# --------------------
d1181 4
a1184 1
    my $basics = $root->findnodes("basics")->[0];
d1186 3
a1188 3
# --------------------
# Start updating the current values
# --------------------
d1190 1
a1190 1
    $basics->setAttribute("ep-total", $state->{"ep-total"});
d1193 5
a1197 5
    my ($tick, $calandar) = &DqDate($basics->getAttribute('date'));

    $basics->setAttribute("date", TickToCDate($state->{'tick'}, $calandar));
    $basics->setAttribute("tick", $state->{'tick'});
    $basics->setAttribute("calandar", $calandar);
d1284 43
d1336 1
a1336 1
    my %opts;
a1338 1
    my $cp = "utf8";
d1340 10
a1349 5
    getopts("e:i:o:", \%opts);

    $cp = $opts{"e"} if (exists($opts{"e"}));

    if ($opts{"i"})
d1351 1
a1351 1
	open(IN, "<:encoding($cp)", $opts{"i"}) || die "Cannot open file.";
d1359 7
a1365 9
    my $doc = XML::LibXML::Document->new("1.0", "UTF-8");
    my $root = $doc->createElement("character");
    $doc->setDocumentElement($root);
    $root->setAttribute("system", "dq");

#    my $pi = $res->createPI("xml-stylesheet", "href=\"direct.css\" type=\"text/css\"");
#    $res->insertBefore($pi, $root);

    my $basics = XML::LibXML::Element->new("basics"); $root->appendChild($basics);
d1369 27
a1395 13
	$basics->setAttribute("short", $1) if (m:^\\charname{(.*)}:);
	$basics->setAttribute("name", $1) if (m:^\\fullname{(.*)}:);
	$basics->setAttribute("race", $1) if (m:^\\race{(.*)}:);
	$basics->setAttribute("college", $1) if (m:^\\college{(.*)}:);
	$basics->setAttribute("status", $1) if (m:^\\status{(.*)}:);
	$basics->setAttribute("sex", $1) if (m:^\\sex{(.*)}:);
	$basics->setAttribute("height", $1) if (m:^\\height{(.*)}:);
	$basics->setAttribute("weight", $1) if (m:^\\weight{(.*)}:);
	$basics->setAttribute("aspect", $1) if (m:^\\aspect{(.*)}:);
	$basics->setAttribute("hand", $1) if (m:^\\hand{(.*)}:);
	$basics->setAttribute("birth", $1) if (m:^\\birth{(.*)}:);
	$basics->setAttribute("date", $1) if (m:^\\date{(.*)}:);
	$basics->setAttribute("dateofbirth", $1) if (m:^\\dateofbirth{(.*)}:);
d1397 1
a1397 5
	&DoAdventure($in, $root) if (m:^\\begin\{adventure\*?\}:);
    }
    my $conf = {};
    
    &XML_Update($conf, $doc);
d1399 1
a1399 1
    if ($opts{"o"})
d1401 1
a1401 5
	$doc->toFile($opts{"o"}, 1);
    }
    else
    {
	print $doc->toString(1);
d1404 1
@


1.5
log
@Add XML update code from update.
@
text
@d1 1
a1 1
#!/usr/bin/perl
d5 1
a5 1
use encoding 'utf8';
d8 1
d43 22
a64 1
	'blossom' => 11
d67 1
a67 1
    $mq = {
d69 1
d71 1
d73 3
a75 1
	'candlemansa' => 9
d78 10
a93 1
    my ($day, $month, $year, $calandar);
d95 7
a101 1
    if (scalar(@@bits) == 4)
d103 2
a104 1
	$calander = pop(@@bits);
d106 6
a111 1
    if ($bits[0] =~ /[A-Za-z]+/)
d113 43
a155 7
	$month = $bits[0];
	$day = $bits[1];
    }
    elsif ($bits[1] =~ /[A-Za-z]+/)
    {
	$month = $bits[1];
	$day = $bits[0];
d157 5
d164 11
a174 7
	$day = $bits[0];
	$month = $bits[1];
    }
    if ($month =~ /[A-Za-z]+/)
    {
	my $t = lc($month);
	if (exists($mq->{$t}))
d176 2
a177 2
	    $month = $mq->{$t};
	    $day = 0;
d179 1
a179 1
	elsif (!exists($mm->{$t}))
d181 15
a195 2
	    print STDERR "Unknown month \'$t\' in \'$date\'.\n";
	    exit(1);
d199 1
a199 1
	    $month = $mm->{$t};
d201 1
a201 6
    }
    else
    {
	$month -= 1;
    }
    $year = $bits[2];
d203 21
a223 25
    if (length($calandar) && !($calandar eq "AP" || $calandar eq "WK"))
    {
	print STDERR "Known calandar \'$calandar\' in date \'$date\'.\n";
	exit 1;
    }
    if (!length($calandar))
    {
	$calandar = ($year > 1900) ? "AP" : "WK";
    }

    my $tick;
    if ($calandar eq "AP")
    {
	my @@md = (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334);
	$tick += ($year - 1970) * 364;
	$tick += $md[$month];
	$tick += $day - 1;
	$tick += 273;
    }
    else
    {
	my @@md = (1, 31, 61, 92, 122, 152, 183, 213, 243, 274, 304, 334);
	$tick += ($year - 770) * 364;
	$tick += $md[$month];
	$tick += $day - 1;
a224 1
    return $tick;
d304 1
a304 1
    my $tick = DqDate($date);
d306 1
d322 6
d342 1
d376 1
a376 1
	    $type = "language" if ($name =~ /Common|Elven|Dwarven|Silent tongue|lunar|children of the traveller|western human|orcish|pixie|pharoan|akadian/i);
d380 1
a380 1
	    $type = "weapon" if ($name =~ /Main gauche|Javelin|Broadsword|Crossbow|Dagger|Shield|Hand and a Half|Unarmed|Sabre|Battle axe|Mace|Scimitar|Quarterstaff|Spear|Cestus|Estoc|Glaive|Grenado|Great axe|sap|rapier|tulwar|short sword|two handed sword|rock|short bow|long bow|composite bow/i);
d495 1
a495 1
    m/\\adventure(\*?)\{(.*)\}\{(.*)\}\{(.*)\}/;
d510 3
a512 1
    $adventure->setAttribute("start-tick", &DqDate($start));
d514 2
a515 1

d519 1
a519 1
	&DoAdventure($in, $root) if (m:^\\adventure:);
d547 4
a550 2

    printf("** %s [%s - %s] **\n\n", $adventure->getAttribute("name"), &TickToWK($start), &TickToWK($end));
d617 1
a617 1
	    my $ep = 0;
d680 2
d687 1
a687 1
			my $sum = $node->getAttribute("sum");
d700 3
a702 3
			    my $em = $node->getAttribute("em");
			    my $cep = $sum * $em;
			    my $ep = $node->hasAttribute("raw-ep") ?
d714 3
a716 3
			    my $ep = $node->getAttribute("ep");
			    my $rep = $node->getAttribute("raw-ep");
			    my $diff = ($rep >= $ep) ? $ep / $rep : $ep / $rep;
a719 1

d731 3
a733 2
		$ep += $node->getAttribute("ep");
		printf("%s (%s..%s)\t Raw EP = %d EP = %d Diff = %d : Time = %s\n",
d737 1
a737 1
	    $block->setAttribute("ep", $ep);
d794 1
a794 1
    printf("Time: start %s - end %s - current %s [%d]\n", TickToWK($start), TickToWK($end), TickToWK($tick), $tick - $end);
d877 7
d951 3
a953 2
	my @@list = sort { $xmap->{$b}->{"rank"} <=> $xmap->{$a}->{"rank"} }  keys %{$xmap};
	
d1001 1
d1023 1
a1023 1
	&DoAdventure($in, $root) if (m:^\\adventure\*?:);
d1025 2
a1026 1

d1031 1
a1031 1
	$doc->toFile($opts{"o"});
@


1.4
log
@Add hack to make early life not part of calander.
@
text
@d6 2
d139 1
a139 1
    my ($adventure) = @@_;
d163 1
a163 1
    my ($adventure) = @@_;
d189 1
a189 1
    my ($adventure) = @@_;
d227 1
a227 1
    my ($root) = @@_;
d275 1
a275 1
	    $type = "skill" if ($name =~ /Mechanician|Horsemanship|Swimming|Stealth|Climbing|Military Scientist|Weaponsmith|Ranger|Healer|Spy|Armourer|Flying|Warrior|thief|troubadour|Alchemist|Assassin|Merchant|Distiller|Courtesan|herbalist|artisan|Navigator|cook|astrologer|philosopher|Baker|Artisan (Cook)|brewer|glassblower/i);
d277 1
a277 1
	    $type = "weapon" if ($name =~ /Main gauche|Javelin|Broadsword|Crossbow|Dagger|Shield|Hand and a Half|Unarmed|Sabre|Battle axe|Mace|Scimitar|Quarterstaff|Spear|Cestus|Estoc|Glaive|Grenado|Great axe|sap|rapier|tulwar|short sword|two handed sword|rock/i);
d337 1
a337 1
    my ($adventure) = @@_;
d391 1
a391 1
    my ($root) = @@_;
d398 1
a398 1
    $adventure->setAttribute("star", 1) if(length($1) || ($2 =~ /early life/i));
d412 6
a417 6
	&DoRanking($adventure) if (m:^\\begin\{ranking\*?\}:);
	&DoAdventure($root) if (m:^\\adventure:);
	&DoExperience($adventure) if (m:^\\experience:);
	&DoParty($adventure) if (m:^\\begin\{party\}:);
	&DoMonies($adventure) if (m:^\\begin\{monies\}:);
	&DoItems($adventure) if (m:^\\begin\{items\}:);
d425 428
d862 7
a868 1
    getopts("i:o:", \%opts);
d871 1
a871 1
	open(IN, $opts{"i"}) || die "Cannot open file.";
d879 3
a881 3
    my $res = XML::LibXML::Document->new("1.0", "UTF-8");
    my $root = $res->createElement("character");
    $res->setDocumentElement($root);
d883 2
a884 2
    my $pi = $res->createPI("xml-stylesheet", "href=\"direct.css\" type=\"text/css\"");
    $res->insertBefore($pi, $root);
d904 1
a904 1
	&DoAdventure($root) if (m:^\\adventure\*?:);
d907 2
d911 1
a911 3
	my $o = $opts{"o"};
	open(OUT, ">$o") || die "Cannot open $o.";
	$out = \*OUT;
d915 1
a915 1
	$out = \*STDOUT;
a916 2

    print $out $res->toString(1);
@


1.3
log
@Check in before adding date.
@
text
@d4 125
d140 1
a140 1
    while (<STDIN>)
d169 1
a169 1
    while (<STDIN>)
d189 1
d197 1
d204 1
d206 5
a210 1
    while (<STDIN>)
d226 1
a226 1
    m/\\begin\{ranking\}\{(.*)\}/;
d228 3
a230 1
    $ranking->setAttribute("desc", $1);
d232 1
a232 1
    while(<STDIN>)
d238 1
a238 1
	return if (m:^\\end\{ranking\}:);
d271 1
a271 1
	    $type = "language" if ($name =~ /Common|Elven|Dwarven|Silent tongue|lunar|children of the traveller|western human|orcish|pixie/i);
d273 1
a273 1
	    $type = "skill" if ($name =~ /Mechanician|Horsemanship|Swimming|Stealth|Climbing|Military Scientist|Weaponsmith|Ranger|Healer|Spy|Armourer|Flying|Warrior|thief|troubadour|Alchemist|Assassin|Merchant|Distiller|Courtesan|herbalist|artisan|Navigator|cook|astrologer|philosopher|Baker|Artisan (Cook)/i);
d361 1
a361 1
	$_ = <STDIN>;
d382 6
d390 2
a391 1
    m/\\adventure\{(.*)\}\{(.*)\}/;
d393 16
a408 3
    $adventure->setAttribute("name", $1);
    $adventure->setAttribute("date", $2);
    while(<STDIN>)
d410 1
a410 1
	&DoRanking($adventure) if (m:^\\begin\{ranking\}:);
d423 6
d430 16
a445 3
    my $out = XML::LibXML::Document->new("1.0", "ISO-8859-1");
    my $root = $out->createElement("character");
    $out->setDocumentElement($root);
d447 2
a448 2
    my $pi = $out->createPI("xml-stylesheet", "href=\"direct.css\" type=\"text/css\"");
    $out->insertBefore($pi, $root);
d451 1
a451 1
    while(<STDIN>)
d468 12
a479 1
	&DoAdventure($root) if (m:^\\adventure:);
d482 1
a482 1
    print STDOUT $out->toString(1);
@


1.2
log
@Add system attribute to character node.
@
text
@d1 1
a1 1
#!/opt/perl5/bin/perl
d230 1
a230 1
    if ($items[0])
d236 1
a236 1
	$exp->setAttribute("out", $items[3]) if ($items[3]);
@


1.1
log
@Initial revision
@
text
@d270 4
a273 5
    my $parser = XML::LibXML->new();
    my $out = $parser->parse_string("<character/>");
    $out->setEncoding("iso-8859-1");

    my $root = $out->getDocumentElement();
@
